/*
 *
 *  File:    main.cpp
 *  Author:  Baoyun Peng
 *  Created: Sep 7, 2016
 */

/*! \mainpage Matlab Mat File Parser and Write it to searilization binary file for C++ OpenCV
 *
 * MatlabIO provides the ability to read .Mat files generated by Matlab
 * into C++ programs. MatlabIO stores matrices in the OpenCV cv::Mat format
 * and is intrinsically designed for computer vision research and applications,
 * though other fields may find use in the features it provides. It has a simple,
 * easy to use interface for parsing files, searching for particular variables
 * and extracting the data in OpenCV native formats.
 */

#include <string>
#include <opencv2/core/core.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/highgui/highgui.hpp>
#include "MatlabIO.hpp"
#include "MatlabIOContainer.hpp"
#include "pca_model.hpp"
#include <fstream>

using namespace cv;
using namespace std;


int main(int argc, char **argv)
{

    // get the Matlab .Mat file from the command line
    string filename(argv[1]);

    // create a new reader
    MatlabIO matio;
    bool ok = matio.open(filename, "r");
    if (!ok)
        return -1;

    // read all of the variables in the file
    vector<MatlabIOContainer> variables;
    variables = matio.read();

    // close the file
    matio.close();

    PcaModel pca_shape_model;
    PcaModel expr_model;

    // display the file info
    matio.whos(variables);

    cv::Mat tempMat;
    for (unsigned int n = 0; n < variables.size(); ++n)
    {
        //get the shape information
        if (variables[n].name().compare("mu_shape") == 0)
        {
            pca_shape_model.mean = variables[n].data<Mat>();
            std::cout<<pca_shape_model.mean.rows<<'\t'<<pca_shape_model.mean.cols<<std::endl;
            //cvtColor(im, im, CV_RGB2BGR);
        }
        if (variables[n].name().compare("pca_shape") == 0)
        {
            pca_shape_model.normalised_pca_basis = variables[n].data<Mat>();
            std::cout<<pca_shape_model.normalised_pca_basis.rows<<'\t'<<pca_shape_model.normalised_pca_basis.cols<<std::endl;
        }
         if (variables[n].name().compare("tri") == 0)
        {
            tempMat = variables[n].data<Mat>();
            std::cout<<tempMat.rows<<'\t'<<tempMat.cols<<std::endl;
            for (int r = 0; r < tempMat.cols; r=r+3)
            {
                std::array<int, 3> temp;
                temp[0] = tempMat.at<int>(r,0);
                temp[1] = tempMat.at<int>(r+1,0);
                temp[2] = tempMat.at<int>(r+2,0);
                pca_shape_model.triangle_list.push_back(temp);
            }

        }
        //get the expression information
         if (variables[n].name().compare("mu_exp") == 0)
        {
            expr_model.mean = variables[n].data<Mat>();
            std::cout<<expr_model.mean.rows<<'\t'<<expr_model.mean.cols<<std::endl;
        }
         if (variables[n].name().compare("expr_disp_intel") == 0)
        {
            expr_model.normalised_pca_basis = variables[n].data<Mat>();
            std::cout<<expr_model.normalised_pca_basis.rows<<'\t'<<expr_model.normalised_pca_basis.cols<<std::endl;
        }
    }


    ofstream shape_file("pca_shape_basis.bin", std::ios::binary);
    cereal::BinaryOutputArchive shape_archive(shape_file);
    shape_archive( pca_shape_model );

    ofstream expr_file("expression_basis.bin", std::ios::binary);
    cereal::BinaryOutputArchive expr_archive(expr_file);
    expr_archive( expr_model );

    return 0;
}
